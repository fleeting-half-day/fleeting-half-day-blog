---
title: "Java 内存模型（JMM）"
date: 2023-07-19
metaAlignment: center
categories:
- Java基础
tags:
- JMM
- 内存模型
---

<!--more-->

### Java 内存模型

#### 主内存与工作内存

Java 内存模型规定所有变量都存储在主内存，每条线程有工作线程，工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，不能直接读写主内存的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递需要通过主内存来完成。

#### 内存间交互

关于主内存与工作内存之间具体的交互协议，Java 内存模型中定义了以下 8 种操作来完成。

**lock（锁定）**：作用于主内存的变量，标识变量为线程独占状态。

**unlock（解锁）**：作用于主内存的变量，释放变量锁定状态。

**read（读取）**：作用于主内存的变量，把变量的值从主内存传输到工作线程中，以便随后的 load 操作使用。

**load（载入）**：作用于工作内存的变量，把 read 操作从主内存得到的变量值放入工作内存的变量副本中。

**use（使用）**：作用于工作内存的变量，把工作内存中一个变量的值传递给执行引擎，虚拟机遇到使用该变量值的字节码指令时将会执行这个操作。

**assign（赋值）**：作用于工作内存中的变量，把一个从执行引擎接收到的值复制给工作内存的变量，虚拟机遇到给变量赋值的字节码指令时执行这个操作。

**store（存储）**：作用于工作内存中的变量，把工作工作内存中一个变量的值传送到主内存中，以便随后的 write 操作使用。

**write（写入）**：作用于主内存中的变量，把 store 操作从工作内存中得到的变量的值放入主内存的变量中。

*Java 内存模型还规定执行上述8种基本操作的时候必须满足如下规则：*
* 不允许 read 和 load、store 和 write 操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起了回写但主内存不接受的情况出现。
* 不允许一个线程丢弃最近的 assign 操作，即变量在工作内存中改变了之后必须把改变同步回主内存。
* 不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从工作内存同步回主内存。
* 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load 和 assign）的变量，换句话说，就是对一个变量实施 use、store 操作之前，必须先执行了assign 和load 操作。
* 一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。
* 如果对一个变量执行 lock 操作，会清空工作内存中该变量的值，在执行引擎使用这个变量前，需要重新执行 lock 或 assign 操作初始化变量的值。
* 如果一个变量事先没有被 lock 操作锁定，那就不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定的变量。
* 对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中（执行 store、write 操作）。

#### volatile 变量特殊规则

一个变量定义为 volatile 之后，具备两种特性：**第一是保证此变量对所有线程的可见性**，这里“可见性”指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的；**第二是禁止指令重排序优化**。
* 有 volatile 修饰的变量，赋值后多执行了一个 lock 操作，这个操作相当于一个内存屏障（Memory Barrier 或 Memory Fence，指重排序时不能把后面的指令重排序到内存屏障之前），只有一个 CPU 访问内存时，并不需要内存屏障；但如果有两个或更多 CPU 访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性了。lock 操作的作用是使得本 CPU 的 Cache 写入内存，该写入操作也会引起别的 CPU 或者别的内核无效化其 Cache，所以可以让前面 volatile 变量的修改对其他 CPU 立即可见。
* 指令重排序是指 CPU 采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理。但并不是说指令任意重排，CPU 需要能正确处理指令依赖情况以保障程序能得出正确的执行结果。因此，lock 指令把修改同步到内存时，意味着所以之前的操作都已经执行完成，这样便形成了“指令重排序无法越过内存屏障”的效果。

#### 对于 long 和 double 变量的特殊规则

Java 内存模型要求 lock、unlock、read、assign、use、store、write 这 8 个操作都具有原子性，但是对于 64 位的数据类型（long 和 double），在模型中特别定义了一条相对宽松的规定：允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虚拟机实现选择可以不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性，这就是所谓的 long 和 double 的非原子性协议。

#### 原子性、可见性与有序性

Java 内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这 3 个特征来建立的。

##### 原子性
由 Java 内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store 和write 这六个， 我们大致可以认为，基本数据类型的访问、读写都是具备原子性的（例外就是long和double的非原子性协定，读者只要知道这件事情就可以了，无须太过在意这些几乎不会发生的例外情况）。

如果应用场景需要一个更大范围的原子性保证（经常会遇到），Java 内存模型还提供了 lock 和 unlock 操作来满足这种需求，尽管虚拟机未把 lock 和 unlock 操作直接开放给用户使用，但是却提供了更高层次的字节码指令 monitorenter 和 monitorexit 来隐式地使用这两个操作。这两个字节码指令反映到 Java 代码中就是同步块—— synchronized 关键字，因此在 synchronized 块之间的操作也具备原子性。  

##### 可见性
可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。上文在讲解 volatile 变量的时候我们已详细讨论过这一点。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是 volatile 变量都是如此。普通变量与 volatile 变量的区别是，volatile 的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此我们可以说 volatile 保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。

除了 volatile 之外，Java 还有两个关键字能实现可见性，它们是 synchronized 和 final。同步块的可见性是由“对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中（执行 store、write 操 作）”这条规则获得的。而 final 关键字的可见性是指：被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this 引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程中就能看见 final 字段的值。  

##### 有序性
Java 内存模型的有序性在前面讲解 volatile 时也比较详细地讨论过了，Java 程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内似表现为串行的语义”（Within-Thread As-If-Serial Semantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。

Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 关键字本身就包含了禁止指令重排序的语义，而 synchronized 则是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。

#### 先行发生原则
如果 Java 内存模型中所有的有序性都仅靠 volatile 和 synchronized 来完成，那么有很多操作都将会变得非常啰嗦，但是我们在编写 Java 并发代码的时候并没有察觉到这一点，这是因为 Java 语言中有一个“先行发生”（Happens-Before）的原则。这个原则非常重要，它是判断数据是否存在竞争，线程是否安全的非常有用的手段。依赖这个原则，我们可以通过几条简单规则一揽子解决并发环境下两个操作之间是否可能存在冲突的所有问题，而不需要陷入 Java 内存模型苦涩难懂的定义之中。  

现在就来看看“先行发生”原则指的是什么。先行发生是 Java 内存模型中定义的两项操作之间的偏序关系，比如说操作 A 先行发生于操作 B，其实就是说在发生操作 B 之前，操作 A 产生的影响能被操作 B 观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。  

下面是 Java 内存模型下一些“天然的”先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来，则它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。  

**程序次序规则（Program Order Rule）**：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循 环等结构。

**管程锁定规则（Monitor Lock Rule）**：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。这里必须强调的是“同一个锁”，而“后面”是指时间上的先后。

**volatile变量规则（Volatile Variable Rule）**：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后。

**线程启动规则（Thread Start Rule）**：Thread 对象的 start() 方法先行发生于此线程的每一个动作。

**线程终止规则（Thread Termination Rule）**：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过 Thread::join() 方法是否结束、Thread::isAlive() 的返回值等手段检测线程是否已经终止执行。

**线程中断规则（Thread Interruption Rule）**：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 Thread::interrupted() 方法检测到是否有中断发生。

**对象终结规则（Finalizer Rule）**：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。

**传递性（Transitivity）**：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于操作 C 的结论。