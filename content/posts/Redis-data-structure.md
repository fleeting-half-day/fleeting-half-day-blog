---
title: "Redis 系列（一）：底层数据结构"
date: 2023-07-31T14:20:32+08:00
metaAlignment: center
categories:
- Redis 系列
tags:
- Redis
- 数据结构
---

<!--more-->

## Redis 底层数据结构

### 简单动态字符串

##### 简单动态字符串定义
```
struct sdshdr {
	// buf数组已使用字节数
	int len;
	// buf数组未使用字节数
	int free;
	// 字节数组，用户保存字符串
	char buf[];
}
```

##### 简单动态字符串特性
* 常数复杂度获取字符串长度
	- 由于 len 属性的存在，获取 SDS 字符串的长度只需要读取 len 属性，时间复杂度为 O(1)。
* 杜绝缓冲区溢出
	- C 语言中使用 strcat 函数进行两个字符串的拼接，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。而 SDS 数据类型，在进行字符串修改的时候，会先根据 len 属性检查内存空间是否满足需求，如果不满足，会进行相应的空间扩展，然后再进行修改操作，避免了缓冲区溢出。
* 减少修改字符串的内存重新分配次数
	- 空间预分配：对字符串进行空间扩展的时候，扩展内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。
	- 惰性空间释放：对字符串进行缩短操作时，程序不立即重新分配来回收缩短后多余的字节，而是使用free属性将这些字节的梳理记录下来，等待后续使用（SDS 提供了 API，可以手动释放这些未使用的空间）。
* 二进制安全
	- 因为C字符串以空字符串作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；而所有 SDS 的 API 虽然也都是以处理二进制的方式来处理buf里面的元素，但 SDS 并不是以空字符串来判断是否结束，而是以 len 属性表示的长度来判断字符串是否结束。
* 兼容部分 C 字符串函数
	- 虽然 SDS 是二进制安全的，但是一样遵从每个字符串都是以空字符串结尾的惯例，这样可以重用 C 语言库<string.h>中的一部分函数。

### 链表

##### 链表定义
```
typedef struct listNode {
	// 前置节点
	struct listNode *prev;
	// 后置节点
	struct listNode *next;
	// 节点的值
	void *value;
} listNode;
// 多个 listNode 组成一个双向链表
typedef struct list {
	// 头节点
	listNode *head;
	// 尾节点
	listNode *tail;
	// 链表总节点数量
	unsigned long len;
	// 节点值复制函数
	void (*free) (void *ptr);
	// 节点值释放函数
	void (*free) (void *key);
	// 节点值对比函数
	int (*match) (void *ptr, void *key);
} list;
```

##### 链表特性
* 双端：链表节点具有前置节点和后置节点的引用，获取这两个节点时间复杂度都为 O(1)。
* 无环：头节点的 prev 指针和尾节点的 next 指针都指向 NULL，对链表的访问都是以 NULL 结束。
* 带链表长度计数器：通过 len 属性获取链表长度，时间复杂度为 O(1)。
* 多态：链表节点使用 void* 指针来保存节点值，可以保存各种不同类型的值。

### 字典
> 字典又称为符号表、关联数组或映射（map），是一种用于保存简直对的抽象数据结构。字典中每一个键 key 都是唯一的，通过 key 可以对值进行查找或修改。

##### 字典定义
```
typedef struct dictht {
	// 哈希表数组
	dictEntry **table;
	// 哈希表大小
	unsigned long size;
	// 哈希表大小掩码，用于计算索引值 size - 1
	unsigned long sizemask;
	// 哈希表已有节点数量
	unsighed long used;
} dictht;

typedef struct dictEntry {
	// 键
	void *key;
	// 值：可以是指针，也可以是uint64_t整数，也可以是int64_t整数
	union {
		void *val;
		unint64_tu64;
		int64_ts64;
	}
	// 指向下一个哈希表节点
	struct dictEntry *next;
} dictEntry;
```

##### 字典特性
哈希表最大的问题是哈希冲突，解决哈希冲突的方法有 *开发地址法* 和 *链地址法*。这里采用的是 *链地址法*，通过 next 指针将多个哈希值相同的键值对连接起来。
* 扩容和收缩：如果执行扩容操作，根据原哈希表已使用的空间扩大一倍创建一个新的哈希表。如果是收缩操作，根据已使用的空间缩小一半创建一个新的哈希表。
* 扩容触发条件：
	- 如果服务器没有在执行 BGSAVE 或 BGREWRITEAOF 命令，负载因子大于等于1。
	- 如果服务器正在执行 BGSAVE 或 BGREWRITEAOF 命令，负载因子大于等于5。

	ps：负载因子 = 哈希表已存节点数量 / 哈希表大小。

### 跳跃表
> 跳跃表是是一个有序数据结构，通过在每个节点中维护多个指向其他节点的指针，从而达到快速访问节点的目的。

##### 跳跃表定义
```
// 跳跃表节点
typedef struct zskiplistNode {
	struct zskiplistLevel {
		// 前进指针
		struct zskiplistNode * forward;
		// 跨度
		unsigned int span;
	} level[];
	// 后退指针
	struct zskiplistNode *backward;
	// 分值
	double score;
	// 成员对象
	robj *obj;
} zskiplistNode;
// 多个跳跃表节点构成一个跳跃表
typedef struct zskiplist {
	// 头节点和尾节点
	struct zskiplistNode *header, *tail;
	// 跳跃表节点数量
	unsigned long length;
	// 跳跃表最大层数
	int level;
} zskiplist;

```

##### 跳跃表特性
* 跳跃表有多层结构，每一层都是一个有序列表，排列顺序为由高层到底层，每层至少包含前节点 head 和后节点 nil。
* 链表的每个节点都包含两个指针，一个指向同一层的下一个链表节点，另一个指向下一层的同一个链表节点。
* 如果一个元素出现在某一层的链表，那么在盖层之下的链表也全都会出现（上一层元素是当前层元素的子集）。
* 最底层包含所有元素；

##### 跳跃表操作
* 搜索：从最高层链表节点开始，如果比当前节点大比当前层下一个节点小，那么往下层找，和下一层节点的下一个节点比较，以此类推，一直找到最底层的最后一个节点，如果找到就返回，否则返回空。
* 插入：首先确定冲入的层数，有一种方法是假设抛一枚硬币，如果是正面就累加，直到遇见反面为止，最后记录正面的次数作为插入的层数。当确定插入的层数 k 后，则需要将新元素插入到底层到 k 层。
* 删除：在各层中找到包含指定值的节点，然后将节点从链表中删除。如果删除以后只剩下头尾两个节点，则删除这一层。

### 整数集合
> 整数集合（intset）是 Redis 用于保存整数值的集合抽象数据类型，它可以保存int16_t、int32_t 或者 int64_t 的整数值，并且保证集合中不会出现重复元素。

##### 整数集合定义
```
typedef struct intset {
	// 编码方式
	uint32_t encoding;
	// 集合的元素数量
	uint32_t length;
	// 保存元素的数组
	int8_t contents[];
} intset;
```
整数集合的每个元素都是 contents 数组的一个数据项，按照从小到大的顺序排列，并且不包含任何重复项。
需要主要的是 contents 数组虽然声明为 int8_t 类型，但实际上 contents 数组并不保存任务类型的 int8_t 类型的值，其真正的类型由 encoding 来决定。

##### 整数集合特性
* 升级：当新增元素类型比原集合元素类型的长度大时，需要对整数集合进行升级，才能将新元素放入整数集合中。具体步骤如下：
	- 根据新元素类型，扩展整数集合底层数组大小，并为新元素分配空间。
	- 将现有元素都转成与新元素类型相同的元素，并将转换后的元素放到正确的位置，防止过程中，保证数组元素有序。
	- 将新元素添加到整数集合中（保证有序）。
	
	升级能极大的节省内存。
* 降级：整数集合不支持降级操作，一旦升级，编码就会一直保持升级后的状态。

### 压缩列表
> 压缩列表（ziplist）是 Redis 为了节省内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构，一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或一个整数值。

##### 压缩列表原理
*压缩列表并不是对数据利用某种算法进行压缩，而是将数据按照一定的规则编码在一块连续的内存区域，达到节省内存的目的。*
压缩列表节点构成如下：
* previous_entry_ength：记录压缩列表前一个节点的字节长度。previous_entry_ength 的长度可能是 1 字节或者 5 字节，如果上一个节点的长度小于 254，则该节点只需要一个字节就可以表示前一个节点的长度；如果前一个节点的长度大于等于 254，则 previous length 的第一个字节为 254，后面用四个字节表示当前节点前一个节点的长度。即当前节点位置减去上一个节点的长度就是上一个节点的起始位置，压缩列表可以从尾部向头部遍历。有效地减少了内存的浪费。
* content：保存节点内容。
* encoding：保存节点 content 内容类型和长度，encoding 类型一共有两种，字节数组和整数，encoding 区域长度为 1 字节、2 字节或 5 字节。

参考：[Redis详解](https://www.cnblogs.com/ysocean/tag/Redis详解/)